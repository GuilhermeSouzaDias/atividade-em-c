//exercicio 1
void inserir_inicio(No** inicio, int valor) {
    No* novo = criar_no(valor);
    novo->proximo = *inicio;
    *inicio = novo;
}

void inserir_fim(No** inicio, int valor) {
    No* novo = criar_no(valor);
    if (*inicio == NULL) {
        *inicio = novo;
        return;
    }
    No* atual = *inicio;
    while (atual->proximo != NULL) {
        atual = atual->proximo;
    }
    atual->proximo = novo;
}

            //main exercicio 1
            int main() {
                    No* lista = NULL;
                
                    inserir_inicio(&lista, 10);
                    inserir_inicio(&lista, 20);
                    inserir_fim(&lista, 30);
                    inserir_fim(&lista, 40);
                
                    printf("Lista atual:\n");
                    imprimir_lista(lista);  
                
                    liberar_lista(lista);
                    return 0;
                }



//exercicio 2

int contar_nos(No* inicio) {
    int contador = 0;
    No* atual = inicio;
    while (atual != NULL) {
        contador++;
        atual = atual->proximo;
    }
    return contador;
}

        //main exercicio 2
            int main() {
            No* lista = NULL;
        
            inserir_fim(&lista, 1);
            inserir_fim(&lista, 2);
            inserir_fim(&lista, 3);
            inserir_fim(&lista, 4);
        
            printf("Número de nós na lista: %d\n", contar_nos(lista));
        
            liberar_lista(lista);
            return 0;
            }



//exercicio 3
int buscar_elemento(No* inicio, int valor_buscado) {
    No* atual = inicio;
    while (atual != NULL) {
        if (atual->valor == valor_buscado) {
            return 1; 
        }
        atual = atual->proximo;
    }
    return 0; 
}
        //main exercicio3
            int main() {
                No* n1 = criar_no(10);
                No* n2 = criar_no(20);
                No* n3 = criar_no(30);
                n1->proximo = n2;
                n2->proximo = n3;
            
                printf("Buscar 20: %d\n", buscar_elemento(n1, 20)); // Saída: 1
                printf("Buscar 40: %d\n", buscar_elemento(n1, 40)); // Saída: 0
            
                free(n1);
                free(n2);
                free(n3);
            
                return 0;
            }



//exercicio 4 
void inserir_posicao(No** inicio, int valor, int posicao) {
    if (posicao < 0) {
        printf("Posição inválida.\n");
        return;
    }

    No* novo = criar_no(valor);

    if (posicao == 0) {
        novo->proximo = *inicio;
        *inicio = novo;
        return;
    }
   
    No* atual = *inicio;
    int i = 0;
    while (atual != NULL && i < posicao - 1) {
        atual = atual->proximo;
        i++;
    }

    if (atual == NULL) {
        printf("Posição fora dos limites da lista.\n");
        free(novo);
        return;
    }

    novo->proximo = atual->proximo;
    atual->proximo = novo;
}
        //main exercicio 4
            int main() {
            No* lista = NULL;
        
            // Lista inicial: vazia
            inserir_posicao(&lista, 10, 0); 
            inserir_posicao(&lista, 20, 1); 
            inserir_posicao(&lista, 30, 1);
            inserir_posicao(&lista, 5, 0);  
        
            imprimir_lista(lista); 
        
            liberar_lista(lista);
            return 0;

            }



//exercicio 5
void remover_valor(No** inicio, int valor) {
    No* atual = *inicio;
    No* anterior = NULL;

    while (atual != NULL) {
        if (atual->valor == valor) {
            if (anterior == NULL) {
                // Remover o primeiro nó
                *inicio = atual->proximo;
            } else {
                // Remover nó do meio ou fim
                anterior->proximo = atual->proximo;
            }
            free(atual);
            printf("Valor %d removido.\n", valor);
            return;
        }
        anterior = atual;
        atual = atual->proximo;
    }

    printf("Valor %d não encontrado.\n", valor);
}
                //main exercicio 5
                    int main() {
                No* lista = NULL;
                inserir_fim(&lista, 10);
                inserir_fim(&lista, 20);
                inserir_fim(&lista, 30);
                inserir_fim(&lista, 40);
                inserir_fim(&lista, 20);
            
                printf("Lista original:\n");
                imprimir_lista(lista); 
            
                remover_valor(&lista, 20); 
            
                printf("Lista após remover 20:\n");
                imprimir_lista(lista);
            
                remover_valor(&lista, 99); // Tenta remover valor que não existe
            
                liberar_lista(lista);
                return 0;
                }



//exercicio 6
void inverter_lista(No** inicio) {
    No* anterior = NULL;
    No* atual = *inicio;
    No* proximo = NULL;

    while (atual != NULL) {
        proximo = atual->proximo;  
        atual->proximo = anterior; 
        anterior = atual;          
        atual = proximo;           
    }

    *inicio = anterior; 
}
        //main exercicio 6 
                int main() {
            No* lista = NULL;
        
            inserir_fim(&lista, 1);
            inserir_fim(&lista, 2);
            inserir_fim(&lista, 3);
            inserir_fim(&lista, 4);
            inserir_fim(&lista, 5);
        
            printf("Lista original:\n");
            imprimir_lista(lista);  
        
            inverter_lista(&lista);
        
            printf("Lista invertida:\n");
            imprimir_lista(lista);  
        
            liberar_lista(lista);
            return 0;
        }



//exercicio 7
No* encontrar_meio(No* inicio) {
    if (inicio == NULL) return NULL;

    No* lento = inicio;
    No* rapido = inicio;

    while (rapido != NULL && rapido->proximo != NULL) {
        lento = lento->proximo;
        rapido = rapido->proximo->proximo;
    }

    return lento; 
}
        //main exercicio 7
            int main() {
            No* lista = NULL;
        
            inserir_fim(&lista, 10);
            inserir_fim(&lista, 20);
            inserir_fim(&lista, 30);
            inserir_fim(&lista, 40);
            inserir_fim(&lista, 50);
        
            printf("Lista:\n");
            imprimir_lista(lista);
        
            No* meio = encontrar_meio(lista);
            if (meio != NULL)
                printf("Nó do meio: %d\n", meio->valor); 
        
            liberar_lista(lista);
            return 0;
        }



//exercicio 8
void imprimir_reverso(No* inicio) {
    //Contar o número de nós
    int tamanho = 0;
    No* atual = inicio;
    while (atual != NULL) {
        tamanho++;
        atual = atual->proximo;
    }

    //Empilhar os valores
    Pilha* pilha = criar_pilha(tamanho);
    atual = inicio;
    while (atual != NULL) {
        empilhar(pilha, atual->valor);
        atual = atual->proximo;
    }

    //Desempilhar os valores
    printf("Lista em ordem reversa:\n");
    while (!pilha_vazia(pilha)) {
        printf("%d -> ", desempilhar(pilha));
    }
    printf("NULL\n");

    liberar_pilha(pilha);
}
                //main exercicio 8
                            int main() {
                    No* lista = NULL;
                
                    inserir_fim(&lista, 10);
                    inserir_fim(&lista, 20);
                    inserir_fim(&lista, 30);
                    inserir_fim(&lista, 40);
                
                    printf("Impressão reversa:\n");
                    imprimir_reverso(lista);
                
                    liberar_lista(lista);
                    return 0;
                }


//exercicio 9

int pilha[TAMANHO_MAX];
int topo_pilha = -1;

int esta_vazia() {
    return topo_pilha == -1;
}

void push(int valor) {
    if (topo_pilha == TAMANHO_MAX - 1) {
        printf("Erro: Pilha cheia!\n");
        return;
    }
    topo_pilha++;
    pilha[topo_pilha] = valor;
}

void pop() {
    if (esta_vazia()) {
        printf("Erro: Pilha vazia!\n");
        return;
    }
    topo_pilha--;
}

int topo() {
    if (esta_vazia()) {
        printf("Erro: Pilha vazia!\n");
        exit(1); 
    }
    return pilha[topo_pilha];
}
        //main exercicio 9
            int main() {
            push(10);
            push(20);
            push(30);
        
            printf("Topo da pilha: %d\n", topo()); // Esperado: 30
        
            pop();
            printf("Topo após pop: %d\n", topo()); // Esperado: 20
        
            while (!esta_vazia()) {
                printf("Removendo: %d\n", topo());
                pop();
            }
        
            pop(); // Tentativa de remover de pilha vazia
        
            return 0;
            }
        



//exercicio 10
typedef struct No {
    int valor;
    struct No* proximo;
} No;


typedef struct {
    No* topo;
} Pilha;


Pilha* criar_pilha() {
    Pilha* pilha = (Pilha*)malloc(sizeof(Pilha));
    pilha->topo = NULL;
    return pilha;
}

int esta_vazia(Pilha* pilha) {
    return pilha->topo == NULL;
}

void push(Pilha* pilha, int valor) {
    No* novo = (No*)malloc(sizeof(No));
    if (!novo) {
        printf("Erro de alocação de memória.\n");
        exit(1);
    }
    novo->valor = valor;
    novo->proximo = pilha->topo;
    pilha->topo = novo;
}

void pop(Pilha* pilha) {
    if (esta_vazia(pilha)) {
        printf("Erro: pilha vazia!\n");
        return;
    }
    No* temp = pilha->topo;
    pilha->topo = pilha->topo->proximo;
    free(temp);
}

int topo(Pilha* pilha) {
    if (esta_vazia(pilha)) {
        printf("Erro: pilha vazia!\n");
        exit(1); 
    }
    return pilha->topo->valor;
}

void liberar_pilha(Pilha* pilha) {
    while (!esta_vazia(pilha)) {
        pop(pilha);
    }
    free(pilha);
}
        //main exercicio 10
            int main() {
            Pilha* pilha = criar_pilha();
        
            push(pilha, 10);
            push(pilha, 20);
            push(pilha, 30);
        
            printf("Topo: %d\n", topo(pilha)); // Esperado: 30
        
            pop(pilha);
            printf("Topo após pop: %d\n", topo(pilha)); // Esperado: 20
        
            while (!esta_vazia(pilha)) {
                printf("Removendo: %d\n", topo(pilha));
                pop(pilha);
            }
        
            pop(pilha); // Tentativa de remover de pilha vazia
        
            liberar_pilha(pilha);
            return 0;
            }



//exercicio 11
int verificar_balanceamento(const char* str) {
    char pilha[MAX];
    int topo = -1;

    for (int i = 0; str[i] != '\0'; i++) {
        char c = str[i];

        if (c == '(' || c == '[' || c == '{') {
            if (topo == MAX - 1) {
                printf("Erro: pilha cheia.\n");
                return 0;
            }
            pilha[++topo] = c;
        }
      
        else if (c == ')' || c == ']' || c == '}') {
            if (topo == -1 || !corresponde(pilha[topo], c)) {
                return 0; // Desbalanceado
            }
            topo--; // Remove o topo
        }
    }

    return topo == -1;
}
            //main exercicio 11
                int main() {
                const char* teste1 = "({[]})";
                const char* teste2 = "({[})";
                const char* teste3 = "(()[]{}{[]})";
            
                printf("Teste 1: %s -> %s\n", teste1, verificar_balanceamento(teste1) ? "Válido" : "Inválido");
                printf("Teste 2: %s -> %s\n", teste2, verificar_balanceamento(teste2) ? "Válido" : "Inválido");
                printf("Teste 3: %s -> %s\n", teste3, verificar_balanceamento(teste3) ? "Válido" : "Inválido");
            
                return 0;
                }



//exercicio 12
void inverter_string(char* str) {
    char pilha[MAX];
    int topo = -1;
    int i;

    for (i = 0; str[i] != '\0'; i++) {
        pilha[++topo] = str[i];
    }

    for (i = 0; topo >= 0; i++) {
        str[i] = pilha[topo--];
    }
    str[i] = '\0';
}
                    //main exercicio 12
                        int main() {
                        char palavra[MAX];
                    
                        printf("Digite uma string: ");
                        scanf("%s", palavra);
                    
                        inverter_string(palavra);
                    
                        printf("String invertida: %s\n", palavra);
                    
                        return 0;
                        }



//exercicio 13
int ehPalindromo(const char *str) {
    Pilha pilha;
    inicializaPilha(&pilha);

    int len = strlen(str);

                //main exercicio 13
                    int main() {
                        char str[MAX];
                        printf("Digite uma string: ");
                        fgets(str, MAX, stdin);
                        str[strcspn(str, "\n")] = 0;  // Remove o caractere de nova linha da entrada
                    
                        if (ehPalindromo(str)) {
                            printf("A string é um palíndromo.\n");
                        } else {
                            printf("A string não é um palíndromo.\n");
                        }
                    
                        return 0;
                    }


//exercicio 14
void empilhar(Pilha *p, int item) {
    if (!pilhaCheia(p)) {
        p->items[++(p->top)] = item;
    }
}

int desempilhar(Pilha *p) {
    if (!pilhaVazia(p)) {
        return p->items[(p->top)--];
    }
    return -1;  // Caso a pilha esteja vazia
}

int topo(Pilha *p) {
    if (!pilhaVazia(p)) {
        return p->items[p->top];
    }
    return -1;  // Caso a pilha esteja vazia
}

void ordenarPilha(Pilha *pOriginal) {
    Pilha pAuxiliar;
    inicializaPilha(&pAuxiliar);

    while (!pilhaVazia(pOriginal)) {
        // Desempilha o elemento da pilha original
        int temp = desempilhar(pOriginal);

        while (!pilhaVazia(&pAuxiliar) && topo(&pAuxiliar) > temp) {
            empilhar(pOriginal, desempilhar(&pAuxiliar));
        }

        empilhar(&pAuxiliar, temp);
    }

    while (!pilhaVazia(&pAuxiliar)) {
        empilhar(pOriginal, desempilhar(&pAuxiliar));
    }
}
void imprimirPilha(Pilha *p) {
    if (pilhaVazia(p)) {
        printf("A pilha está vazia.\n");
        return;
    }

    printf("Pilha: ");
    for (int i = 0; i <= p->top; i++) {
        printf("%d ", p->items[i]);
    }
    printf("\n");
}

                //main exercicio 14
                            int main() {
                                Pilha p;
                                inicializaPilha(&p);
                            
                                // Adicionando alguns elementos à pilha
                                empilhar(&p, 5);
                                empilhar(&p, 1);
                                empilhar(&p, 8);
                                empilhar(&p, 3);
                                empilhar(&p, 7);
                            
                                printf("Pilha original:\n");
                                imprimirPilha(&p);
                            
                                // Ordenando a pilha
                                ordenarPilha(&p);
                            
                                printf("Pilha ordenada:\n");
                                imprimirPilha(&p);
                            
                                return 0;
                            }



//exercicio 15
#define MAX 100

typedef struct {
    int fila[MAX];
    int frente;
    int cauda;
} Fila;

void inicializaFila(Fila *f) {
    f->frente = 0;
    f->cauda = 0;
}

int filaVazia(Fila *f) {
    return f->frente == f->cauda;
}

int filaCheia(Fila *f) {
    return (f->cauda + 1) % MAX == f->frente;
}

void enfileirar(Fila *f, int item) {
    if (filaCheia(f)) {
        printf("Erro: Fila cheia!\n");
    } else {
        f->fila[f->cauda] = item;
        f->cauda = (f->cauda + 1) % MAX;
    }
}

int desenfileirar(Fila *f) {
    if (filaVazia(f)) {
        printf("Erro: Fila vazia!\n");
        return -1;  
    } else {
        int item = f->fila[f->frente];
        f->frente = (f->frente + 1) % MAX;  
        return item;
    }
}

int frente(Fila *f) {
    if (filaVazia(f)) {
        printf("Erro: Fila vazia!\n");
        return -1;
    } else {
        return f->fila[f->frente];
    }
}

void imprimirFila(Fila *f) {
    if (filaVazia(f)) {
        printf("A fila está vazia.\n");
        return;
    }

    printf("Fila: ");
    int i = f->frente;
    while (i != f->cauda) {
        printf("%d ", f->fila[i]);
        i = (i + 1) % MAX;
    }
    printf("\n");
}

                    //main exercicio 15
                            int main() {
                                Fila f;
                                inicializaFila(&f);

                                enfileirar(&f, 10);
                                enfileirar(&f, 20);
                                enfileirar(&f, 30);
                                enfileirar(&f, 40);
                            
                                imprimirFila(&f);
                            
                                printf("Frente da fila: %d\n", frente(&f));
                            
                                printf("Desenfileirando: %d\n", desenfileirar(&f));
                                imprimirFila(&f);
                            
                                enfileirar(&f, 50);
                                enfileirar(&f, 60);
                            
                                imprimirFila(&f);
                            
                                return 0;
                            }

//exercicio 16
Queue* createQueue() {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    q->front = q->rear = NULL;
    return q;
}

int isEmpty(Queue* q) {
    return (q->front == NULL);
}

void enqueue(Queue* q, int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = NULL;

    if (q->rear == NULL) {
        q->front = q->rear = newNode;
    } else {
        q->rear->next = newNode;
        q->rear = newNode;
    }
}

int dequeue(Queue* q) {
    if (isEmpty(q)) {
        printf("Fila vazia. Não é possível remover.\n");
        return -1;
    }

    Node* temp = q->front;
    int value = temp->data;

    q->front = q->front->next;

    if (q->front == NULL)
        q->rear = NULL;

    free(temp);
    return value;
}

int peek(Queue* q) {
    if (isEmpty(q)) {
        printf("Fila vazia.\n");
        return -1;
    }
    return q->front->data;
}

void freeQueue(Queue* q) {
    while (!isEmpty(q)) {
        dequeue(q);
    }
    free(q);
}

                //main exercicio 16
                    int main() {
                        Queue* q = createQueue();
                    
                        enqueue(q, 10);
                        enqueue(q, 20);
                        enqueue(q, 30);
                    
                        printf("Frente da fila: %d\n", peek(q));
                    
                        printf("Removido: %d\n", dequeue(q));
                        printf("Frente após remoção: %d\n", peek(q));
                    
                        freeQueue(q);
                        return 0;
                    }

//exercicio 17 
void generateBinaryNumbers(int N) {
    Queue* q = createQueue();
    enqueue(q, "1");

    for (int i = 0; i < N; i++) {
        char* current = dequeue(q);
        printf("%s\n", current);

        int len = strlen(current);
        char* left = (char*)malloc(len + 2);
        char* right = (char*)malloc(len + 2);

        strcpy(left, current);
        strcat(left, "0");

        strcpy(right, current);
        strcat(right, "1");

        enqueue(q, left);
        enqueue(q, right);

        free(current);
        free(left);
        free(right);
    }

    freeQueue(q);
}
                //main exercicio 17
                    int main() {
                        int N = 10;
                        printf("Primeiros %d números binários:\n", N);
                        generateBinaryNumbers(N);
                        return 0;
                    }

//exericio 18
void inverter_primeiros_k(Queue* q, int k) {
    if (k <= 0 || isQueueEmpty(q)) return;

    Stack* s = createStack();

    for (int i = 0; i < k && !isQueueEmpty(q); i++) {
        push(s, dequeue(q));
    }

    while (!isStackEmpty(s)) {
        enqueue(q, pop(s));
    }

    int size = 0;
    Node* temp = q->front;
    while (temp) {
        size++;
        temp = temp->next;
    }

    int rest = size - k;
    for (int i = 0; i < rest; i++) {
        enqueue(q, dequeue(q));
    }

    free(s);
}
                    //main exercicio 18
                        int main() {
                            Queue* q = createQueue();

                            for (int i = 1; i <= 7; i++) {
                                enqueue(q, i);
                            }
                        
                            printf("Fila original: ");
                            printQueue(q);
                        
                            int k = 4;
                            inverter_primeiros_k(q, k);
                        
                            printf("Fila após inverter os primeiros %d elementos: ", k);
                            printQueue(q);
                        
                            return 0;
                        }

//exercicio 19
int detectar_ciclo(Node* head) {
    Node* slow = head;
    Node* fast = head;

    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast) return 1;
    }

    return 0;
}
                    //main exercicio 19
                        int main() {
                            Node* head = novoNo(1);
                            head->next = novoNo(2);
                            head->next->next = novoNo(3);
                            head->next->next->next = novoNo(4);
                            head->next->next->next->next = head->next; // Cria ciclo
                        
                            if (detectar_ciclo(head)) {
                                printf("Ciclo detectado na lista.\n");
                            } else {
                                printf("Nenhum ciclo na lista.\n");
                            }

                            return 0;
                        }

//exercicio 20
Node* unir_listas_ordenadas(Node* l1, Node* l2) {
    // Lista dummy para facilitar
    Node dummy;
    dummy.next = NULL;
    Node* tail = &dummy;

    while (l1 != NULL && l2 != NULL) {
        if (l1->data <= l2->data) {
            tail->next = l1;
            l1 = l1->next;
        } else {
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
    }
                        //main exercicio 20
                            int main() {
                                Node* lista1 = NULL;
                                Node* lista2 = NULL;
      
                                inserir_fim(&lista1, 1);
                                inserir_fim(&lista1, 3);
                                inserir_fim(&lista1, 5);
                            
                                inserir_fim(&lista2, 2);
                                inserir_fim(&lista2, 4);
                                inserir_fim(&lista2, 6);
                            
                                printf("Lista 1: ");
                                imprimir_lista(lista1);
                                printf("Lista 2: ");
                                imprimir_lista(lista2);
                            
                                Node* unida = unir_listas_ordenadas(lista1, lista2);
                            
                                printf("Lista unida: ");
                                imprimir_lista(unida);
                            
                                return 0;
                            }
        

//exercicio 21 
void remover_todas_ocorrencias(No** head, int valor) {
    No* atual = *head;
    No* anterior = NULL;

    while (atual != NULL) {
        if (atual->valor == valor) {
            No* temp = atual;
            if (anterior == NULL) {
                // Removendo o primeiro nó
                *head = atual->prox;
            } else {
                anterior->prox = atual->prox;
            }
            atual = atual->prox;
            free(temp);
        } else {
            anterior = atual;
            atual = atual->prox;
        }
    }
}

        //main exercicio 21
            int main() {
                No* lista = NULL;
            
                inserir_inicio(&lista, 3);
                inserir_inicio(&lista, 5);
                inserir_inicio(&lista, 3);
                inserir_inicio(&lista, 7);
                inserir_inicio(&lista, 3);
            
                printf("Lista original:\n");
                imprimir_lista(lista);
            
                remover_todas_ocorrencias(&lista, 3);
            
                printf("Lista após remover todas as ocorrências de 3:\n");
                imprimir_lista(lista);
            
                return 0;
            }

//exercicio 22 
No* encontrar_intersecao(No* head1, No* head2) {
    int len1 = contar_nos(head1);
    int len2 = contar_nos(head2);

    int diff = abs(len1 - len2);

    if (len1 > len2) {
        for (int i = 0; i < diff; i++) {
            head1 = head1->prox;
        }
    } else {
        for (int i = 0; i < diff; i++) {
            head2 = head2->prox;
        }
    }

                //main exercicio 22
                    int main() {
    
                        No* lista1 = novo_no(1);
                        lista1->prox = novo_no(2);
                        lista1->prox->prox = novo_no(3);
                    
                      
                        No* lista2 = novo_no(9);
                        lista2->prox = novo_no(8);
                        lista2->prox->prox = lista1->prox->prox;  
                    
                        printf("Lista 1: ");
                        imprimir_lista(lista1);
                    
                        printf("Lista 2: ");
                        imprimir_lista(lista2);
                    
                        No* intersecao = encontrar_intersecao(lista1, lista2);
                        if (intersecao) {
                            printf("Interseção encontrada no nó com valor: %d\n", intersecao->valor);
                        } else {
                            printf("Nenhuma interseção encontrada.\n");
                        }
                    
                        return 0;
                    }


//exercicio 23
void rotacionar_lista(No** head_ref, int k) {
    if (*head_ref == NULL || k == 0) return;

    // Passo 1: contar o tamanho da lista
    No* temp = *head_ref;
    int tamanho = 1;
    while (temp->prox != NULL) {
        temp = temp->prox;
        tamanho++;
    }

    // Fazer k rotação efetiva
    k = k % tamanho;
    if (k == 0) return;

    // Passo 2: tornar a lista circular
    temp->prox = *head_ref;

    // Passo 3: encontrar o novo final da lista (tamanho - k) e o novo início
    int passos = tamanho - k;
    No* novo_fim = *head_ref;
    for (int i = 1; i < passos; i++) {
        novo_fim = novo_fim->prox;
    }

    // Passo 4: quebrar o círculo e atualizar o head
    *head_ref = novo_fim->prox;
    novo_fim->prox = NULL;
}
                            //main exercicio 23
                                int main() {
                                    No* lista = NULL;
                                
                                    inserir_fim(&lista, 1);
                                    inserir_fim(&lista, 2);
                                    inserir_fim(&lista, 3);
                                    inserir_fim(&lista, 4);
                                    inserir_fim(&lista, 5);
                                
                                    printf("Lista original:\n");
                                    imprimir_lista(lista);
                                
                                    int k = 2;
                                    rotacionar_lista(&lista, k);
                                
                                    printf("Lista após rotacionar %d posições:\n", k);
                                    imprimir_lista(lista);
                                
                                    return 0;
                                }



//exercicio 24
typedef struct PilhaComMin {
    Pilha principal;
    Pilha minimos;
} PilhaComMin;

// Inicializa a pilha com mínimo
void inicializar_pilha_com_min(PilhaComMin* p) {
    inicializar(&p->principal);
    inicializar(&p->minimos);
}

// Push com controle de mínimo
void push_com_min(PilhaComMin* p, int valor) {
    push(&p->principal, valor);
    if (esta_vazia(&p->minimos) || valor <= top(&p->minimos)) {
        push(&p->minimos, valor);
    }
}

// Pop com controle de mínimo
int pop_com_min(PilhaComMin* p) {
    int removido = pop(&p->principal);
    if (removido == top(&p->minimos)) {
        pop(&p->minimos);
    }
    return removido;
}
                    //main exercicio 24
                            int main() {
                                PilhaComMin pilha;
                                inicializar_pilha_com_min(&pilha);
                            
                                push_com_min(&pilha, 3);
                                push_com_min(&pilha, 5);
                                printf("Min: %d\n", obter_minimo(&pilha)); // 3
                                push_com_min(&pilha, 2);
                                push_com_min(&pilha, 1);
                                printf("Min: %d\n", obter_minimo(&pilha)); // 1
                                pop_com_min(&pilha);
                                printf("Min: %d\n", obter_minimo(&pilha)); // 2
                                pop_com_min(&pilha);
                                printf("Topo: %d\n", top_com_min(&pilha)); // 5
                                printf("Min: %d\n", obter_minimo(&pilha)); // 3
                            
                                return 0;
                            }


//exercicio 25

typedef struct {
    int arr[MAX];
    int topo1;
    int topo2;
} DuasPilhas;

void inicializar(DuasPilhas* pilhas) {
    pilhas->topo1 = -1;
    pilhas->topo2 = MAX;
}

void empilhar1(DuasPilhas* pilhas, int valor) {
    if (pilhas->topo1 + 1 < pilhas->topo2) {
        pilhas->topo1++;
        pilhas->arr[pilhas->topo1] = valor;
    } else {
        printf("Estouro de pilha 1\n");
    }
}

// Empilha na pilha 2 (direita → esquerda)
void empilhar2(DuasPilhas* pilhas, int valor) {
    if (pilhas->topo2 - 1 > pilhas->topo1) {
        pilhas->topo2--;
        pilhas->arr[pilhas->topo2] = valor;
    } else {
        printf("Estouro de pilha 2\n");
    }
}

int desempilhar1(DuasPilhas* pilhas) {
    if (pilhas->topo1 >= 0) {
        int valor = pilhas->arr[pilhas->topo1];
        pilhas->topo1--;
        return valor;
    } else {
        printf("Pilha 1 vazia\n");
        return -1;
    }
}
int desempilhar2(DuasPilhas* pilhas) {
    if (pilhas->topo2 < MAX) {
        int valor = pilhas->arr[pilhas->topo2];
        pilhas->topo2++;
        return valor;
    } else {
        printf("Pilha 2 vazia\n");
        return -1;
    }
}


                //main exercicio 25
                    int main() {
                        DuasPilhas pilhas;
                        inicializar(&pilhas);
                    
                        empilhar1(&pilhas, 10);
                        empilhar1(&pilhas, 20);
                        empilhar2(&pilhas, 100);
                        empilhar2(&pilhas, 200);
                    
                        printf("Desempilhando da pilha 1: %d\n", desempilhar1(&pilhas)); // 20
                        printf("Desempilhando da pilha 2: %d\n", desempilhar2(&pilhas)); // 200
                    
                        return 0;
                    }


//exercicio 26
int eh_operador(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/');
}

// Função para aplicar o operador a dois operandos
int aplicar_operador(int op1, int op2, char operador) {
    switch (operador) {
        case '+': return op1 + op2;
        case '-': return op1 - op2;
        case '*': return op1 * op2;
        case '/': return op1 / op2;
        default:
            printf("Operador inválido: %c\n", operador);
            exit(1);
    }
}

// Função para avaliar a expressão pós-fixa
int avaliar_posfixa(const char* expressao) {
    int pilha[MAX];
    int topo = -1;

    char token[20];
    int i = 0, j = 0;

    while (expressao[i]) {
        if (isspace(expressao[i])) {
            i++;
            continue;
        }

        if (isdigit(expressao[i]) || (expressao[i] == '-' && isdigit(expressao[i+1]))) {
            // Ler número (suporta negativos)
            j = 0;
            while (expressao[i] && (isdigit(expressao[i]) || expressao[i] == '-')) {
                token[j++] = expressao[i++];
            }
            token[j] = '\0';
            pilha[++topo] = atoi(token);
        } else if (eh_operador(expressao[i])) {
            if (topo < 1) {
                printf("Erro: expressão inválida\n");
                exit(1);
            }
            int op2 = pilha[topo--];
            int op1 = pilha[topo--];
            int resultado = aplicar_operador(op1, op2, expressao[i]);
            pilha[++topo] = resultado;
            i++;
        } else {
            printf("Caractere inválido: %c\n", expressao[i]);
            exit(1);
        }
    }

    if (topo != 0) {
        printf("Erro: expressão malformada\n");
        exit(1);
    }

    return pilha[topo];
}

                    //main exericio 26
                        int main() {
                            const char* expressao = "3 4 + 2 *";  // Resultado esperado: 14
                            int resultado = avaliar_posfixa(expressao);
                            printf("Resultado: %d\n", resultado);
                            return 0;
                        }

